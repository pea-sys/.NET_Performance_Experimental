以下書籍の和訳書のハンズオン  
https://www.manning.com/books/unit-testing

---

## [メモ]

## なぜ、単体テストを行うのか？

- コードベースの秩序を維持・改善するために必要
- プロジェクトの成長を維持するために必要
- 品質に貢献する価値あるテストのみを行う
- 網羅率に固執して時間を浪費しないこと
- 優れたテストスイートは開発サイクルの中で自然に行われる(コンパイルエラーのようなもの)

---

## 単体テストとは何か？

- 単体テストとは以下の 3 つの性質を持ったテスト
  - 1 単位の振る舞いを検証すること
  - 実行時間が短いこと
  - 他のテストケースから隔離された状態で実行されること
- 統合テストとは、上記 3 つの性質の 1 つでも損なっているテスト

* E2E テストは統合テストの 1 種。全てのプロセス外依存を使うテストする

---

- 単体テストには、ロンドン学派と古典学派の２つの学派が存在する
  - ロンドン学派：単体とは 1 単位のコード(クラス)を指す。すべての不変依存をテストダブルに置き換える
  - 古典学派：単体とは 1 単位のテストケースを指す。他のテストケースに影響を与える可能性のある共有依存のみテストダブルに置き換える
    (※日本における TDD の第一人者は古典学派。基本的にモックは使わないにこしたことはないという考え。)

---

## 単体テストの構造

- 単体テストは １つの AAA パターン構造のみにすると保守性が向上する
  - 準備(Arrange)
  - 実行(Act)
  - 確認(Assert)

* 実行フェーズが 1 行ではない場合、テスト対象 API の設計が誤っている可能性が高い。

* テストの可読性を上げるため、テスト対象システム(System Under Test)のオブジェクト名を「sut」で統一すること。

* テストコードの共有にコンストラクタは使用しないこと。  
  インスタンスの準備にはファクトリー関数を用意する等。

* テストメソッドの命名は以下に従うと良い。

  - 厳密な命名規則を付けないこと
  - 単語はアンダースコアで区切ること
  - 非開発者にもわかるテストケース名にすること

* パラメータ化テストは汎用的にしすぎるとテストシナリオが分かりにくくなるため、乱用しないように注意が必要

---

## 良い単体テストを構成する 4 本の柱

- 退行に対する保護
- リファクタリングへの耐性
- 迅速なフィードバック
- 保守のしやすさ

※保守のしやすさ以外は背反する性質であるため、全てを完全にするのは不可能。テストピラミッドの層により重要度も変わる。

※テストを作成する際はブラックボックス視点。テストを分析する際にはホワイトボックス視点を持つこと。

---

## モックの利用とテストの壊れやすさ

- スタブとのやり取りを検証する必要はない
- 観察可能な振る舞いと API を可能な限り一致させること。そうでない場合、実装の詳細が漏洩することになる。

* ヘキサゴナルアーキテクチャには３つの重要な性質がある。
  - ドメイン層とアプリケーションサービス層が分離されている
  - ドメイン層からアプリケーションサービス層を呼び出さない
  - 外部アプリケーションからドメイン層に直接アクセスさせない

---

## 単体テストの３つの手法

- 1. 出力値ベーステスト・・・テスト対象システムに入力値を敢えて、そこで生成された結果を検証する手法
- 2. 状態ベーステスト・・・テスト対象システムと協力者オブジェクトの状態を検証する手法
- 3. コミュニケーションベーステスト・・・モックを使ってテスト対象システムと協力者オブジェクトのコミュニケーションを検証する手法

* 質の高いテストケース順 : 出力値ベーステスト ＞ 状態ベーステスト ＞ コミュニケーションベーステスト

* 関数型アーキテクチャを導入することでビジネスロジックと副作用を分離することを目指す
* 関数型アーキテクチャは副作用をビジネスオペレーションの最初や最後に持っていくことで分離を実現しようとする。

* 関数型アーキテクチャの導入により保守性は上がるがパフォーマンスが下がるリスクがある。

---

## 単体テストの価値を高めるリファクタリング

- コードの複雑さ・・・対象となるコードの決定を下す分岐の数。呼び出しライブラリによる暗黙的な分岐も存在する。
- ドメインにおける重要性：コードが複雑になるほどドメインにおける重要性が上がる傾向がある。

* 全てのプロダクションコードはコードの複雑さ屋ドメインにおける重要性の観点、および、協力者オブジェクトの数の観点から次の 4 種類に分類できる

  - 1.ドメインモデル/アルゴリズム・・・コードの複雑さやドメインにおける重要性は高いが、協力者オブジェクトの数が少ないコード。この種のコードは単体テストの費用対効果が最も高い。
  - 2.取るに足らないコード・・・コードの複雑さやドメインにおける重要性があまりなく、さらに、協力者オブジェクトの数が少ないコード。単体テストをする価値はない。
  - 3.コントローラ・・・コードの複雑さやドメインにおける重要性はあまりないが、協力者オブジェクトの数が多いコード。総合テストで評価するコード。
  - 4.過度に複雑なコード・・・コードの複雑さやドメインにおける重要性が高く、かつ協力者オブジェクトの数も多いコード。リファクタリングするべきコード。

■ リファクタリング時に使用するパターン

- Humble Object パターン・・・過度に複雑なコードからビジネスロジックを別のクラスに抽出することでテストを行いやすくする設計パターン。コントローラーを用意する。

- CanExecute/Execute パターン・・・何かを実行するメソッドに対して事前に実行可能なのか否かを確認するメソッドを用意するパターン。コントローラが決定を下す責務を取り除くことが出来る

- ドメイン・イベントパターン・・・発生したドメインイベントをもとにプロセス外依存へ呼び出しを行うようにする。コントローラから状態の変更を追跡する責務を取り除くことができる。

- ビジネスロジックの責務はコードの深さと広さとしてみることができるが、深さまたは広さどちらかの性質のみ持たせること

- 事前条件はドメインに重要性がある場合だけテストする

---

## 何故、結合テストを行うのか？

- 統合テストは単体テストではないテストのことである。
  テスト対象システムがプロセス外依存と統合した状態で機能するか評価する
- 統合テストはコントローラに分類されるコードを検証する。
- 早期失敗とは問題が発生したらすぐに処理を失敗させることを提唱している原則であり、統合テストの代わりに使用できる場合がある

* 単体テストでは異常系を出来るだけ多く検証し、統合テストでは単体テストでカバーできない異常系と正常系を検証することでテストピラミッドが適切なバランスになりやすくなる。

- 循環依存はコードを理解しづらくする。値オブジェクトを導入することでリファクタリングが出来る。
- 1 つのテストケースに複数の実行フェーズがあることが許されるのは、プロセス外依存に制限があって開発者がテストのために、そのプロセス外依存に手を入れることが出来ない場合だけ。
- 全ての依存は、コンストラクタやメソッドの引数を経由して明示的に注入されるようにするべき。

---

## モックのベストプラクティス

- スパイは手書きのモックと呼ばれることもあるテストダブルである。モックよりスパイの方がテストコードの量が減り可読性が上がる。
- テストコードにはプロダクションコードを使用してはいけない。プロダクトコードを信頼してはいけないため。
- モックを使うのはコントローラの検証時のみ、つまり統合テストの時だけになる。

---

## データベースに対するテスト

- 開発において各開発者にデータベースインスタンスを持たせるようにする
- 変更すると機能しなくなるデータベースデータは参照データであり、常に維持する必要がある
- 可能な限り単位作業(unit of work)パターンを採用すること
- テストケースの異なるフェーズで同じトランザクションを使用しないこと
- 統合テストではテストケースを１つずつ逐次処理できるようにすれば良い。並列処理はすぐ破綻する。
- テストケースの開始タイミングで他のテストケースが残したデータをクリーンアップする

* テストの際に実運用と異なる DB で評価してはいけない

- 読込みのテストより書き込みテストの方が重要度が高い。重要な読込み以外はテストする必要はない
- リポジトリを直接評価するのはコストが大きいので避ける

---

## 単体テストのアンチパターン

- OR マッパーやファクトリクラス以外において単体テストを行うためにプライベートメソッドをパブリックにしてはいけない

- プロダクトコードの検証にプロダクトコードを使用してはいけない

- テストのためのコードをプロダクションコードに持ち込んではいけない

---

[参考]  
[モックは必要悪で、しないにこしたことはない](https://blog.8-p.info/ja/2021/10/12/mock/)
